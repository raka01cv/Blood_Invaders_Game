<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Blood Invaders</title>
  <style>
    :root{
      --si-bg:#0b1020;            /* game background */
      --si-fg:#e6edf3;            /* text color */
      --si-accent:#7cd1ff;        /* accent (borders/buttons) */
      --si-panel:#121a33;         /* UI panel bg */
      --si-font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--si-bg);color:var(--si-fg);font-family:var(--si-font)}
    .si-wrapper {
    max-width: 98vw; /* 98% of the Viewport Width */
    margin: 24px auto;
    padding: 12px;
}

    .si-card{background:linear-gradient(180deg,#0d142b,#0a0f22 60%);border:1px solid #1a264d;border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.35);overflow:hidden}

    .si-header{display:flex;align-items:center;justify-content:space-between;padding:12px 16px;border-bottom:1px solid #1a264d;background:rgba(255,255,255,.02)}
    .si-title{font-weight:700;letter-spacing:.3px}
    .si-controls{display:flex;gap:8px}
    .si-btn{cursor:pointer;border:1px solid #2a3a73;background:linear-gradient(180deg,#111a37,#0b142e);color:var(--si-fg);padding:8px 12px;border-radius:10px;font-weight:600}
    .si-btn:active{transform:translateY(1px)}

    .si-stage {
    position: relative;
    width: 100%;
    aspect-ratio: 16/9;  /* <--- CHANGED from 4/3 to 16/9 (Widescreen) */
}
    canvas{position:absolute;inset:0;width:100%;height:100%;display:block;background:radial-gradient(80% 120% at 50% 0%, rgba(124,209,255,.10), transparent 55%),
                                radial-gradient(120% 120% at 50% 120%, rgba(124,209,255,.06), transparent 55%),
                                #060a18}

    /* HUD */
    .si-hud{position:absolute;inset:0;pointer-events:none;display:flex;flex-direction:column}
    .si-topbar{display:flex;justify-content:space-between;padding:10px 12px;font-size:14px;opacity:.9;text-shadow:0 1px 0 rgba(0,0,0,.4)}
    .si-center{flex:1;display:grid;place-items:center}
    .si-banner{pointer-events:auto;display:inline-flex;flex-direction:column;gap:10px;align-items:center;justify-content:center;padding:18px 20px;border-radius:14px;background:rgba(8,13,30,.7);backdrop-filter: blur(4px);border:1px solid #1a264d}
    .si-banner h2{margin:0;font-size:20px}
    .si-muted{opacity:.75;font-size:13px}

    /* Mobile on-screen controls */
    .si-mobile{position:absolute;left:0;right:0;bottom:8px;display:none;justify-content:center;gap:10px;pointer-events:auto}
    .si-pad{width:52px;height:52px;border-radius:14px;border:1px solid #23357a;background:linear-gradient(180deg,#0e1736,#0a1230);display:grid;place-items:center;font-weight:900;font-size:18px;user-select:none;color: white;}
    .si-fire{width:100px}

    @media (hover:none) and (pointer:coarse){
      .si-mobile{display:flex}
    }
  </style>
</head>
<body>
  <div class="si-wrapper si-card" id="space-invaders">
    <div class="si-header">
      <div class="si-title">Blood Invaders</div>
      <div class="si-controls">
        <button class="si-btn" data-action="pause" aria-label="Pause/Resume">Pause</button>
        <button class="si-btn" data-action="restart" aria-label="Restart">Restart</button>
      </div>
    </div>
    <div class="si-stage">
      <canvas id="si-canvas" width="1200" height="900" aria-label="Space Invaders game canvas"></canvas>
      <div class="si-hud">
        <div class="si-topbar"><span id="si-score">Score: 0</span><span id="si-lives">Lives: 3</span></div>
        <div class="si-center">
          <div class="si-banner" id="si-banner">
            <h2>Press <kbd>Space</kbd> to Start</h2>
            <div class="si-muted">Move: ⬅️ ➡️  •  Fire: Space / ⌘FIRE</div>
          </div>
        </div>
        <div class="si-mobile">
          <button class="si-pad" data-pad="left" aria-label="Move left">◀︎</button>
          <button class="si-pad si-fire" data-pad="fire" aria-label="Fire">FIRE</button>
          <button class="si-pad" data-pad="right" aria-label="Move right">▶︎</button>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  // --- Public init API (attach to window for easy embedding) ---
  window.SpaceInvaders = { init };

  const DEFAULTS = {
    playerImageSrc: null, 
    alienImageSrcs: [],   
    bullet: {
      count: 4,         // Four blue circular bullets per shot stacked vertically
      radius: 5,
      spacing: 12,      // pixels between bullets in the vertical stack
      color: '#2ea8ff',
      speed: 11,
      cooldownMs: 220
    },
    player: {
      widthPct: 8,      // of canvas width
      heightPct: 8,
      speed: 7,
      lives: 3
    },
    aliens: {
      rows: 5,
      cols: 8,          // Adjusted cols slightly for better spacing with your images
      gutterX: 0.045,   // horizontal spacing (fraction of canvas width)
      gutterY: 0.05,    // vertical spacing (fraction of canvas height)
      sizePct: 7,       // width percent
      baseSpeed: 1.3,
      stepDown: 22      // pixels to drop on wall-bounce
    }
  };

  function init(rootSelector = '#space-invaders', overrides = {}){
    const root = typeof rootSelector === 'string' ? document.querySelector(rootSelector) : rootSelector;
    if(!root) throw new Error('SpaceInvaders: root element not found');
    const canvas = root.querySelector('#si-canvas');
    const scoreEl = root.querySelector('#si-score');
    const livesEl = root.querySelector('#si-lives');
    const bannerEl = root.querySelector('#si-banner');

    const cfg = deepMerge(structuredClone(DEFAULTS), overrides || {});

    const ctx = canvas.getContext('2d');
    let playing = false, paused = false, gameOver = false;
    let score = 0, level = 1;

    // Responsive canvas sizing while keeping drawing space consistent
    function fitCanvas(){
      const rect = canvas.getBoundingClientRect();
      const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
      canvas.width = Math.floor(rect.width * dpr);
      canvas.height = Math.floor(rect.height * dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0); 
    }
    fitCanvas();
    window.addEventListener('resize', fitCanvas);

    // --- Assets ---
    const playerImage = loadImage(cfg.playerImageSrc);
    const alienImages = (cfg.alienImageSrcs || []).map(loadImage);

    // --- Entities ---
    const keys = { left:false, right:false, fire:false };
    const pads = { left:false, right:false, fire:false };

    const player = {
      w: 0, h: 0, x: 0, y: 0, speed: cfg.player.speed, lives: cfg.player.lives,
      reset(){
        const W = canvas.clientWidth, H = canvas.clientHeight;
        this.w = pct(W, cfg.player.widthPct);
        this.h = this.w; // Keep ship square
        this.x = (W - this.w)/2;
        this.y = H - this.h - 16;
      },
      draw(){
        if(playerImage && playerImage.complete && !playerImage.error){
          ctx.drawImage(playerImage, this.x, this.y, this.w, this.h);
        } else {
          // fallback ship (triangle) if image fails
          ctx.save();
          ctx.translate(this.x, this.y);
          ctx.beginPath();
          ctx.moveTo(this.w*0.5, 0);
          ctx.lineTo(this.w*0.9, this.h*0.95);
          ctx.lineTo(this.w*0.1, this.h*0.95);
          ctx.closePath();
          ctx.fillStyle = '#a9c8ff';
          ctx.fill();
          ctx.restore();
        }
      }
    };

    /** Alien formation */
    let aliens = [];
    let alienDir = 1; // 1: right, -1: left
    let alienSpeed = cfg.aliens.baseSpeed; // grows with level

    function spawnAliens(){
      const W = canvas.clientWidth, H = canvas.clientHeight;
      const size = pct(W, cfg.aliens.sizePct);
      aliens = [];
      for(let r=0; r<cfg.aliens.rows; r++){
        for(let c=0; c<cfg.aliens.cols; c++){
          // Rotate through the images based on row index
          const imgIndex = r % alienImages.length;
          const img = alienImages.length ? alienImages[imgIndex] : null;
          
          aliens.push({
            alive: true,
            x: pct(W, 0.06) + c * (size + pct(W, cfg.aliens.gutterX)),
            y: pct(H, 0.08) + r * (size + pct(H, cfg.aliens.gutterY)),
            w: size,
            h: size,
            img
          });
        }
      }
      alienDir = 1;
      alienSpeed = cfg.aliens.baseSpeed + (level-1)*0.25;
    }

    /** Bullets (player only) */
    const bullets = [];
    let lastShotAt = 0;

    function fire(){
      const now = performance.now();
      if(now - lastShotAt < cfg.bullet.cooldownMs) return;
      lastShotAt = now;
      const cx = player.x + player.w/2;
      const baseY = player.y - 8; // just above the ship
      for(let i=0; i<cfg.bullet.count; i++){
        bullets.push({ x: cx, y: baseY - i*cfg.bullet.spacing, r: cfg.bullet.radius, vy: -cfg.bullet.speed });
      }
    }

    // --- Input ---
    window.addEventListener('keydown', (e)=>{
      if(e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = true;
      if(e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = true;
      if(e.code === 'Space') { keys.fire = true; if(!playing && !gameOver) start(); }
    });
    window.addEventListener('keyup', (e)=>{
      if(e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = false;
      if(e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = false;
      if(e.code === 'Space') keys.fire = false;
    });

    root.querySelector('[data-action="pause"]').addEventListener('click', ()=>{
      if(!playing) return; paused = !paused; toggleBanner(paused ? 'Paused — press Space to resume' : '');
    });
    root.querySelector('[data-action="restart"]').addEventListener('click', ()=> restart());

    // Mobile pads
    root.querySelectorAll('[data-pad]').forEach(btn=>{
      const name = btn.getAttribute('data-pad');
      const set = (val)=>{ pads[name] = val; if(name==='fire' && val) { if(!playing && !gameOver) start(); fire(); }}
      const on = ()=>set(true), off=()=>set(false);
      btn.addEventListener('pointerdown', on);
      btn.addEventListener('pointerup', off);
      btn.addEventListener('pointercancel', off);
      btn.addEventListener('pointerleave', off);
    });

    document.addEventListener('visibilitychange', ()=>{ if(document.hidden) paused = true; });

    // --- Game lifecycle ---
    function start(){
      playing = true; paused = false; gameOver = false; bannerEl.style.display='none';
    }

    function restart(){
      score = 0; level = 1; player.lives = cfg.player.lives; bullets.length = 0; 
      player.reset(); // Reset player first to get dimensions
      spawnAliens(); 
      updateHUD(); 
      bannerEl.style.display=''; 
      bannerEl.innerHTML = '<h2>Press <kbd>Space</kbd> to Start</h2><div class="si-muted">Move: ⬅️ ➡️ • Fire: Space / FIRE</div>';
      playing = false; paused = false; gameOver = false;
    }

    function gameOverScreen(text){
      gameOver = true; playing = false; paused = false;
      bannerEl.style.display='';
      bannerEl.innerHTML = `<h2>${text}</h2><div class="si-muted">Press Space to play again</div>`;
    }

    function updateHUD(){
      scoreEl.textContent = `Score: ${score}`;
      livesEl.textContent = `Lives: ${player.lives}`;
    }

    function toggleBanner(message){
      if(message){ bannerEl.style.display=''; bannerEl.innerHTML = `<h2>${message}</h2>`; }
      else bannerEl.style.display='none';
    }

    // helpers
    function pct(n, p){ return (n * p) / 100; }
    function deepMerge(base, patch){
      for(const k in patch){
        if(patch[k] && typeof patch[k] === 'object' && !Array.isArray(patch[k])) base[k] = deepMerge(base[k] || {}, patch[k]);
        else base[k] = patch[k];
      }
      return base;
    }
    function loadImage(src){
      if(!src) return null;
      const img = new Image(); img.decoding='async'; img.src = src;
      img.addEventListener('error', ()=>{ img.error = true; console.warn("Failed to load image:", src); });
      return img;
    }

    // Core loop
    let last = performance.now();
    function tick(now){
      requestAnimationFrame(tick);
      const dt = Math.min(32, now - last); // clamp ms
      last = now;

      fitCanvas(); // keep buffer crisp
      ctx.clearRect(0,0,canvas.clientWidth, canvas.clientHeight);

      if(!playing || paused){
        // Draw static frame
        player.draw();
        drawAliens();
        drawBullets();
        return;
      }

      step(dt/16.6667); // normalize to ~60fps units
      draw();
    }

    function step(t){
      const W = canvas.clientWidth, H = canvas.clientHeight;

      // Player movement
      const left = keys.left || pads.left;
      const right = keys.right || pads.right;
      const fireBtn = keys.fire || pads.fire;
      if(left && !right) player.x = Math.max(0, player.x - player.speed * t);
      if(right && !left) player.x = Math.min(W - player.w, player.x + player.speed * t);
      if(fireBtn) fire();

      // Bullets
      for(const b of bullets){ b.y += b.vy * t; }
      for(let i=bullets.length-1;i>=0;i--) if(bullets[i].y + bullets[i].r < 0) bullets.splice(i,1);

      // Aliens movement
      let hitWall = false;
      for(const a of aliens){
        if(!a.alive) continue;
        a.x += alienDir * alienSpeed * t;
        if(a.x <= 0 || a.x + a.w >= W) hitWall = true;
      }
      if(hitWall){
        alienDir *= -1;
        for(const a of aliens){ a.y += cfg.aliens.stepDown; }
      }

      // Collisions: bullet vs alien
      outer: for(let i=bullets.length-1; i>=0; i--){
        const b = bullets[i];
        for(const a of aliens){
          if(!a.alive) continue;
          if(circleRectIntersect(b.x, b.y, b.r, a.x, a.y, a.w, a.h)){
            a.alive = false; bullets.splice(i,1); score += 10; updateHUD();
            break outer;
          }
        }
      }

      // Win condition -> next level
      if(aliens.every(a=>!a.alive)){
        level++; spawnAliens();
        score += 100; updateHUD();
      }

      // Lose if aliens reach player
      for(const a of aliens){
        if(a.alive && a.y + a.h >= player.y){
          player.lives -= 1; updateHUD();
          if(player.lives <= 0) return gameOverScreen('Game Over');
          spawnAliens();
          break;
        }
      }
    }

    function draw(){
      drawAliens();
      drawBullets();
      player.draw();
    }

    function drawAliens(){
      for(const a of aliens){
        if(!a.alive) continue;
        if(a.img && a.img.complete && !a.img.error){
          // Draw image
          ctx.drawImage(a.img, a.x, a.y, a.w, a.h);
        } else {
          // Fallback block
          ctx.fillStyle = '#7cd1ff';
          ctx.fillRect(a.x, a.y, a.w, a.h);
        }
      }
    }

    function drawBullets(){
      ctx.fillStyle = cfg.bullet.color;
      for(const b of bullets){
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
        ctx.fill();
      }
    }

    function circleRectIntersect(cx, cy, r, rx, ry, rw, rh){
      const nx = Math.max(rx, Math.min(cx, rx+rw));
      const ny = Math.max(ry, Math.min(cy, ry+rh));
      const dx = cx - nx, dy = cy - ny; return (dx*dx + dy*dy) <= r*r;
    }

    // --- INITIALIZE WITH USER IMAGES ---
    // This is where we load the specific files you requested
    restart();
    player.reset();
    requestAnimationFrame(tick);
  }
})();

// Initialize logic with your images
SpaceInvaders.init('#space-invaders', {
  playerImageSrc: 'ship.png',
  alienImageSrcs: [
    'a1.png',
    'a2.png',
    'a3.png',
    'a4.png',
    'a5.png'
  ],

  // SETTINGS FOR THE PLAYER
  player: {
    widthPct: 12,   // <--- INCREASED THIS (Default was 8). Try 14 or 15 for even bigger!
    speed: 7,       // You might want to increase this to 8 or 9 if the ship feels too heavy
    lives: 3
  },
  
  aliens: {
    // I slightly increased the size of the aliens so your images look clear
    sizePct: 6.5 
  }
});
</script>
</body>
</html>
